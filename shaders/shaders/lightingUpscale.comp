#version 450

#define chunkSize 32
#define chunkTileCount 1024
#define chunksX  64 
#define maxLightsPerChunk 100
#define ambiantLight 0.0
#define mapOffset 0
#define mapCount 2097152

struct LightingUpdate {
	int chunkIndex;
	int lightCount;
	vec2 lightPositions[maxLightsPerChunk];
};

layout(std140, set = 0, binding = 0) readonly buffer baseLightingObjectBuffer{
	LightingUpdate[] baseLightingUpdates;
} ;
layout(std140, set = 0, binding = 1) readonly buffer blueLightingObjectBuffer{
	LightingUpdate[] blurLightingUpdates;
} ;

layout(std430, set = 1, binding = 0) buffer mapFGObjectBuffer {
	int tileMapFGData[];
} ;
layout(std430, set = 1, binding = 1) readonly buffer mapBGObjectBuffer {
	int tileMapBGData[];
} ;
layout(std430, set = 1, binding = 2) buffer mapUpscaleObjectBuffer {
	int tileMapUpscaleData[];
} ;
layout(std430, set = 1, binding = 3) buffer mapBlurObjectBuffer {
	int tileMapBlurData[];
} ;

layout(push_constant) uniform constants{
	int interpolationEnabled;
	int upscaleEnabled;
	int blurEnabled;
};

//layout (local_size_x = 64, local_size_y = 64, local_size_z = 1) in;
 layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// todo : use getTile funciton from other shader instead

int getChunkIndex(int x, int y){
    int cx = (x / chunkSize);
    int cy = (y / chunkSize);
    int chunk = cy * chunksX + cx;
    int chuckIndexOffset = chunk * chunkTileCount;
    return mapOffset + chuckIndexOffset + (y % chunkSize) * chunkSize + (x % chunkSize);
}




#define chunkSize2 64
#define chunkTileCount2 4096
#define chunksX2  64 
#define mapw2 4096
#define maph2 2048
#define mapCount2 8388608

void main() 
{

   //  uint x = gl_LocalInvocationID.x;  
   //  uint y = gl_LocalInvocationID.y;  



   //  int chunk = blurLightingUpdates[gl_WorkGroupID.x].chunkIndex;
   //  int chuckIndexOffset = chunk * chunkTileCount;
   //  uint tilemapIndex = chuckIndexOffset + (y * chunkSize) + x;

   //  uint chunkX = chunk % chunksX;
   //  uint chunkY = chunk / chunksX;
   //  uint globX = chunkX * chunkSize + x;
   //  uint globY = chunkY * chunkSize + y;

   // int index = getChunkIndex(int(globX ), int(globY ));
   
   uint x = (gl_LocalInvocationID.x + (gl_WorkGroupID.y * 32)) / 2;  
   uint y = (gl_LocalInvocationID.y + (gl_WorkGroupID.z * 32)) / 2;  



    int chunk = blurLightingUpdates[gl_WorkGroupID.x].chunkIndex;
   int chuckIndexOffset = chunk * chunkTileCount;
   uint tilemapIndex = chuckIndexOffset + (y * chunkSize) + x;

   uint chunkX = chunk % chunksX;
   uint chunkY = chunk / chunksX;
   uint globX = chunkX * chunkSize + x;
   uint globY = chunkY * chunkSize + y; 

   uint x2 = gl_LocalInvocationID.x + (gl_WorkGroupID.y * 32);  
   uint y2 = gl_LocalInvocationID.y + (gl_WorkGroupID.z * 32);
   int chuckIndexOffset2 = chunk * chunkTileCount2;

   int index = getChunkIndex(int(globX), int(globY));
   int curVal = tileMapBGData[index] >> 16;

   globX += -1 + (x2 % 2);
   globY += -1 + (y2 % 2);

   int vals[4];
   index = getChunkIndex(int(globX + 0), int(globY + 0));
   vals[0] = tileMapBGData[index] >> 16;
   index = getChunkIndex(int(globX + 1), int(globY + 0));
   vals[1] = tileMapBGData[index] >> 16;
   index = getChunkIndex(int(globX + 1), int(globY + 1));
   vals[2] = tileMapBGData[index] >> 16;
   index = getChunkIndex(int(globX + 0), int(globY + 1));
   vals[3] = tileMapBGData[index] >> 16;

   int minv = vals[0];
   int maxv = vals[0];
   minv = min(minv, vals[1]);
   maxv = max(maxv, vals[1]);
   minv = min(minv, vals[2]);
   maxv = max(maxv, vals[2]);
   minv = min(minv, vals[3]);
   maxv = max(maxv, vals[3]);

   int mid = (maxv - minv) / 2;

   int below = 0;
   below += int(vals[0] < mid);
   below += int(vals[1] < mid);
   below += int(vals[2] < mid);
   below += int(vals[3] < mid);

   

//   if(below > 2)
//      curVal = minv;
  if(below < 2)
     curVal = maxv;
   // if(below == 2)
   //    curVal = mid;

   uint tilemapIndex2 = chuckIndexOffset2 + (y2 * chunkSize2) + x2;

   // if(x2 % 2  == 0 && y2 % 2  == 0){
   //    tileMapUpscaleData[tilemapIndex2] =  255;
   // }
   // else{

   //    tileMapUpscaleData[tilemapIndex2] =  0;
   // }

   tileMapUpscaleData[tilemapIndex2] = curVal; //tileMapBGData[tilemapIndex] >> 16;
   tileMapFGData[tilemapIndex] =  (tileMapFGData[tilemapIndex] & 0xFFFF) | (tileMapBGData[tilemapIndex] & 0xFFFF0000);
}


// void main() 
// {

//     uint x = gl_LocalInvocationID.x;  
//     uint y = gl_LocalInvocationID.y;  



//     int chunk = blurLightingUpdates[gl_WorkGroupID.x].chunkIndex;
//     int chuckIndexOffset = chunk * chunkTileCount;
//     uint tilemapIndex = chuckIndexOffset + (y * chunkSize) + x;


//     uint chunkX = chunk % chunksX;
//     uint chunkY = chunk / chunksX;
//     uint globX = chunkX * chunkSize + x;
//     uint globY = chunkY * chunkSize + y;

//     int index = getChunkIndex(int(globX ), int(globY ));
//     int curtile = tileMapFGData[index] & 0xFFFF;

//   //  int curBrightness =  tileMapBGData[mapOffset + index] >> 16;

//     float totalBrightness = 0;
//     int sampleCount = 0;

//     for(int i = -1; i < 2; i++){
//         for(int j = -1; j < 2; j++){

//             index = getChunkIndex(int(globX + i), int(globY + j));
//             int tile = tileMapFGData[ index] & 0xFFFF;
//             int brightness = tileMapBGData[index] >> 16;

//             if(tile == 1023 || curtile != 1023){
//                 sampleCount +=  1;
//                 totalBrightness += brightness;
//             }
//         }
//     }

//     // float brightness = (totalBrightness / 9.0) / 255.0;

//     float brightness = (totalBrightness / float(sampleCount)) / 255.0;
//     brightness = clamp(brightness, ambiantLight, 1.0);

//      //tileMapFGData[tilemapIndex] = (tileMapFGData[tilemapIndex] & 0xFFFF) | int(curBrightness) << 16;
//     tileMapFGData[tilemapIndex] = (tileMapFGData[tilemapIndex] & 0xFFFF) | int(brightness * 255) << 16;
// }

// totalBrightness += getBrightness(int(globX), int(globY));
// totalBrightness += getBrightness(int(globX + 1), int(globY));
// totalBrightness += getBrightness(int(globX + 1), int(globY  + 1));
// totalBrightness += getBrightness(int(globX), int(globY  + 1));
// totalBrightness += getBrightness(int(globX - 1), int(globY));
// totalBrightness += getBrightness(int(globX - 1), int(globY - 1));
// totalBrightness += getBrightness(int(globX + 1), int(globY - 1));
// totalBrightness += getBrightness(int(globX - 1), int(globY + 1));
// totalBrightness += getBrightness(int(globX), int(globY - 1));
