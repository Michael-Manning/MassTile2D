#version 450

#define chunkSize 32
#define chunkTileCount 1024
#define chunksX  64 
#define maxLightsPerChunk 100
#define ambiantLight 0.0
#define mapOffset 0
#define mapCount 2097152

struct LightingUpdate {
	int chunkIndex;
	int lightCount;
	vec2 lightPositions[maxLightsPerChunk];
};

layout(std140, set = 0, binding = 0) readonly buffer baseLightingObjectBuffer{
	LightingUpdate[] baseLightingUpdates;
} ;
layout(std140, set = 0, binding = 1) readonly buffer blueLightingObjectBuffer{
	LightingUpdate[] blurLightingUpdates;
} ;

layout(std430, set = 1, binding = 0) buffer mapFGObjectBuffer {
	int tileMapFGData[];
} ;
layout(std430, set = 1, binding = 1) readonly buffer mapBGObjectBuffer {
	int tileMapBGData[];
} ;
layout(std430, set = 1, binding = 2) buffer mapUpscaleObjectBuffer {
	int tileMapUpscaleData[];
} ;
layout(std430, set = 1, binding = 3) buffer mapBlurObjectBuffer {
	int tileMapBlurData[];
} ;

layout(push_constant) uniform LightingSettings{
	int interpolationEnabled;
	int upscaleEnabled;
	int blurEnabled;
};

 layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// todo : use getTile funciton from other shader instead

#define chunkSize2 64
#define chunkTileCount2 4096
#define chunksX2  64 
#define mapw2 4096
#define maph2 2048
#define mapCount2 8388608

int getChunkIndex(int x, int y){
    int cx = (x / chunkSize);
    int cy = (y / chunkSize);
    int chunk = cy * chunksX + cx;
    int chuckIndexOffset = chunk * chunkTileCount;
    return chuckIndexOffset + (y % chunkSize) * chunkSize + (x % chunkSize);
}
int getChunkIndex2(int x, int y){
   int cx = (x / chunkSize2);
   int cy = (y / chunkSize2);
   int chunk = cy * chunksX + cx;
   int chuckIndexOffset = chunk * chunkTileCount2;
   return  chuckIndexOffset + (y % chunkSize2) * chunkSize2 + (x % chunkSize2);
}






void main() 
{
   if(upscaleEnabled == 1){
   
      uint x = (gl_LocalInvocationID.x + (gl_WorkGroupID.y * 32)) / 2;  
      uint y = (gl_LocalInvocationID.y + (gl_WorkGroupID.z * 32)) / 2;  

      int chunk = blurLightingUpdates[gl_WorkGroupID.x].chunkIndex;
      int chuckIndexOffset = chunk * chunkTileCount;
      uint tilemapIndex = chuckIndexOffset + (y * chunkSize) + x;

      uint chunkX = chunk % chunksX;
      uint chunkY = chunk / chunksX;

      uint globX = chunkX * chunkSize + x;
      uint globY = chunkY * chunkSize + y; 

      uint x2 = gl_LocalInvocationID.x + (gl_WorkGroupID.y * 32);  
      uint y2 = gl_LocalInvocationID.y + (gl_WorkGroupID.z * 32);

      uint globX2 = chunkX * chunkSize2 + x2;
      uint globY2 = chunkY * chunkSize2 + y2; 


      int chuckIndexOffset2 = chunk * chunkTileCount2;

      int index = 0;
      int index2 = 0;

      index = getChunkIndex(int(globX), int(globY));
      int curtile = tileMapFGData[index] & 0xFFFF;


      float totalBrightness = 0;
      int sampleCount = 0;

      for(int i = -2; i < 3; i++){
         for(int j = -2; j < 3; j++){

            index = getChunkIndex(int(globX + i), int(globY + j));
            index2 = getChunkIndex2(int(globX2 + i), int(globY2 + j));

            int tile = tileMapFGData[index] & 0xFFFF;
            int brightness = tileMapUpscaleData[index2];

            if(tile == 1023 || curtile != 1023){
                  sampleCount +=  1;
                  totalBrightness += brightness;
            }
         }
      }


      uint tilemapIndex2 = chuckIndexOffset2 + (y2 * chunkSize2) + x2;

      float brightness = (totalBrightness / float(sampleCount)) / 255.0;

      brightness = clamp(brightness, ambiantLight, 1.0);  

      tileMapBlurData[tilemapIndex2] =  int(brightness * 255); 
      return;
   }

   uint x = gl_LocalInvocationID.x;  
   uint y = gl_LocalInvocationID.y;  



   int chunk = blurLightingUpdates[gl_WorkGroupID.x].chunkIndex;
   int chuckIndexOffset = chunk * chunkTileCount;
   uint tilemapIndex = chuckIndexOffset + (y * chunkSize) + x;


   uint chunkX = chunk % chunksX;
   uint chunkY = chunk / chunksX;
   uint globX = chunkX * chunkSize + x;
   uint globY = chunkY * chunkSize + y;

   int index = getChunkIndex(int(globX ), int(globY ));
   int curtile = tileMapFGData[index] & 0xFFFF;

//  int curBrightness =  tileMapBGData[mapOffset + index] >> 16;

   float totalBrightness = 0;
   int sampleCount = 0;

   for(int i = -1; i < 2; i++){
      for(int j = -1; j < 2; j++){

         index = getChunkIndex(int(globX + i), int(globY + j));
         int tile = tileMapFGData[ index] & 0xFFFF;
         int brightness = tileMapBGData[index] >> 16;

         if(tile == 1023 || curtile != 1023){
               sampleCount +=  1;
               totalBrightness += brightness;
         }
      }
   }

   // float brightness = (totalBrightness / 9.0) / 255.0;

   float brightness = (totalBrightness / float(sampleCount)) / 255.0;
   brightness = clamp(brightness, ambiantLight, 1.0);

   //tileMapFGData[tilemapIndex] = (tileMapFGData[tilemapIndex] & 0xFFFF) | int(curBrightness) << 16;
   tileMapFGData[tilemapIndex] = (tileMapFGData[tilemapIndex] & 0xFFFF) | int(brightness * 255) << 16;
}




// void main() 
// {

//     uint x = gl_LocalInvocationID.x;  
//     uint y = gl_LocalInvocationID.y;  



//     int chunk = blurLightingUpdates[gl_WorkGroupID.x].chunkIndex;
//     int chuckIndexOffset = chunk * chunkTileCount;
//     uint tilemapIndex = chuckIndexOffset + (y * chunkSize) + x;


//     uint chunkX = chunk % chunksX;
//     uint chunkY = chunk / chunksX;
//     uint globX = chunkX * chunkSize + x;
//     uint globY = chunkY * chunkSize + y;

//     int index = getChunkIndex(int(globX ), int(globY ));
//     int curtile = tileMapFGData[index] & 0xFFFF;

//   //  int curBrightness =  tileMapBGData[mapOffset + index] >> 16;

//     float totalBrightness = 0;
//     int sampleCount = 0;

//     for(int i = -1; i < 2; i++){
//         for(int j = -1; j < 2; j++){

//             index = getChunkIndex(int(globX + i), int(globY + j));
//             int tile = tileMapFGData[ index] & 0xFFFF;
//             int brightness = tileMapBGData[index] >> 16;

//             if(tile == 1023 || curtile != 1023){
//                 sampleCount +=  1;
//                 totalBrightness += brightness;
//             }
//         }
//     }

//     // float brightness = (totalBrightness / 9.0) / 255.0;

//     float brightness = (totalBrightness / float(sampleCount)) / 255.0;
//     brightness = clamp(brightness, ambiantLight, 1.0);

//      //tileMapFGData[tilemapIndex] = (tileMapFGData[tilemapIndex] & 0xFFFF) | int(curBrightness) << 16;
//     tileMapFGData[tilemapIndex] = (tileMapFGData[tilemapIndex] & 0xFFFF) | int(brightness * 255) << 16;
// }

// totalBrightness += getBrightness(int(globX), int(globY));
// totalBrightness += getBrightness(int(globX + 1), int(globY));
// totalBrightness += getBrightness(int(globX + 1), int(globY  + 1));
// totalBrightness += getBrightness(int(globX), int(globY  + 1));
// totalBrightness += getBrightness(int(globX - 1), int(globY));
// totalBrightness += getBrightness(int(globX - 1), int(globY - 1));
// totalBrightness += getBrightness(int(globX + 1), int(globY - 1));
// totalBrightness += getBrightness(int(globX - 1), int(globY + 1));
// totalBrightness += getBrightness(int(globX), int(globY - 1));
