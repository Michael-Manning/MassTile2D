#version 460

precision highp float;

layout(binding = 1) uniform sampler2D atlasTexture;
#define atlasCount 32;

layout(std430, set = 1, binding = 0) readonly buffer ObjectBuffer{
	int ssboData[];
} ;

layout(push_constant) uniform constants {
   vec2 cameraTranslation;
   float cameraZoom;
   int mapw;
   int maph;
} ;


layout(location = 2) in flat int instance_index;
layout(location = 1) in vec2 uv;
layout(location = 0) out vec4 outColor;


vec4 colors[] = {
   vec4(0.86, 0.2, 0.4, 1.0),
   vec4(0.91, 0.13, 0.88, 1.0),
   vec4(0.97, 0.93, 0.12, 1.0),
   vec4(0.31, 0.97, 0.12, 1.0),
   vec4(0.05, 0.876, 0.94, 1.0),
   vec4(0.21, 0.078, 0.89, 1.0)
};


void main() {



   //float atlasSize = 4;

    // vec2 temp = fract(uv);
    // //temp = clamp(temp, 0., 0.7);
    // vec2 sUv = temp / atlasSize + (1.0 / atlasSize);
    // outColor = texture(atlasTexture, sUv);

    // outColor = texture(atlasTexture, fract(uv) / 4.0 + 0.25);

    vec2 uv2 = fract(uv);
    uv2 = clamp(uv2, 0.1, 0.9);
    outColor = texture(atlasTexture, uv2 / 4.0 + 0.25);




   // int xi = uv.x > 0.5 ? 1 : 0;
   // int yi = uv.y > 0.5 ? 1 : 0;

   // vec2 uvs = uv - 0.5 * vec2(xi, yi);
   // // vec2 sUv = uvs / 2.0 + 0.25;

   // int sx = int(uvs.x * 2.0 * 16) + 16;
   // int sy = int(uvs.y * 2.0 * 16) + 16;

   // outColor = texelFetch(atlasTexture, ivec2(sx, sy), 0); 


  //  float atlasSize = 4;
    // vec2 uv2 = (fract(uv * 2) / atlasSize) + (1.0 / atlasSize);
    // outColor = texelFetch(atlasTexture, ivec2(int(uv2.x * 64), uv2.y * 64), 0); 


// float atlasSize = 4;
// vec2 uv = (fract(uv * 2) / atlasSize) + (1.0 / atlasSize);
// outColor = texelFetch(atlasTexture, ivec2(int(sUv.x * 64), sUv.y * 64), 0); 
// outColor = texture(atlasTexture, uv); 




  // vec2 sUv = uv / atlasSize + (1.0 / atlasSize);

   // vec2 sUv = (fract(uv * 2) / atlasSize) + (1.0 / atlasSize);
   // outColor = vec4(sUv, 0, 1);
   // return;

   // vec2 sUv;

   // if(uv.x < 0.5){
   //    sUv.x = uv.x / 2 + (1.0 / atlasSize);
   //          // outColor = vec4(0.1, 0.1, 0.1, 1);
   //    // return;
   // }
   // else{
   //    sUv.x = (uv.x - 0.5) / 2 +  (1.0 / atlasSize);
   // }



   // if(uv.y <= 0.5){
   //    sUv.y = uv.y / 2 + (1.0 / atlasSize);
   // }
   // else{
   //    sUv.y = (uv.y - 0.5) / 2 +  (1.0 / atlasSize);
   // }

   // outColor = texture(atlasTexture, sUv);







   // int xi = int(uv.x * mapw);
   // xi = min(xi, mapw - 1);

   // int yi = int(uv.y * maph);
   // yi = min(yi, maph - 1);

   // int si = yi * mapw + xi;
   
   // int atlasIndex = ssboData[si];
   // int atlasX = atlasIndex % atlasCount;
   // int atlasY = atlasIndex / atlasCount;

   // float atlasUvSize = 1.0 / atlasCount;

   // vec2 mapUvSize = vec2(1.0 / float(mapw), 1.0 / float(maph));   

   // vec2 localUV = vec2(fract(uv.x * mapw), mod(uv.y * maph, 1.0));
   // vec2 umin = localUV * atlasUvSize + vec2(float(atlasX), float(atlasY)) * atlasUvSize;
   // outColor = texelFetch(atlasTexture, ivec2(int(umin.x * 512), umin.y * 512), 0); 

   // outColor = texture(atlasTexture, umin);







}














 //  outColor = vec4(colors[ssboData[si]]);

//    if(mod(uv.x * mapw, 1.0) > 0.5){
//       si = 3;
//    }
//    else{
//       si = 4;
//    }
//    outColor = vec4(colors[si]);







   // int xi = int(uv.x * mapw);
   // xi = min(xi, mapw - 1);

   // int yi = int(uv.y * maph);
   // yi = min(yi, maph - 1);

   // int si = yi * mapw + xi;
   
   // int atlasIndex = ssboData[si];
   // int atlasX = atlasIndex % atlasCount;
   // int atlasY = atlasIndex / atlasCount;

   // float atlasUvSize = 1.0 / atlasCount;

   // vec2 mapUvSize = vec2(1.0 / float(mapw), 1.0 / float(maph));   

   // vec2 localUV = vec2(fract(uv.x * mapw), mod(uv.y * maph, 1.0));
   // vec2 umin = localUV * atlasUvSize + vec2(float(atlasX), float(atlasY)) * atlasUvSize;
   // outColor = texture(atlasTexture, umin);












   //    vec2 nuv = uv * cameraZoom;
   // nuv /= cameraTranslation;


   // int xi = int(nuv.x * mapw);
   // xi = min(xi, mapw - 1);

   // int yi = int(nuv.y * maph);
   // yi = min(yi, maph - 1);

   // int si = yi * mapw + xi;
   
   // int atlasIndex = ssboData[si];
   // atlasIndex = 5;
   // int atlasX = atlasIndex % atlasCount;
   // int atlasY = atlasIndex / atlasCount;

   // float atlasUvSize = 1.0 / atlasCount;

   // vec2 mapUvSize = vec2(1.0 / float(mapw), 1.0 / float(maph));   

   // vec2 localUV = vec2(mod((1.0 - nuv.x) * mapw, 1.0), mod(nuv.y * maph, 1.0));
   // vec2 umin = localUV * atlasUvSize + vec2(float(atlasX), float(atlasY)) * atlasUvSize;
   // outColor = texture(atlasTexture, umin);


