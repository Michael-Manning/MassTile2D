#version 450

#define MAX_PARTICLES_SMALL 400
#define MAX_PARTICLES_LARGE 4000

#define MAX_PARTICLE_SYSTEMS_LARGE 10

/*

uint hash(uint x) {
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

// Combine the integer seed with the frame seed
uint combineSeed(uint seed, float frameSeed) {
    uint hashFrameSeed = hash(uint(frameSeed * 1000000.0)); // Convert frameSeed to an integer-like hash
    return hash(seed ^ hashFrameSeed);
}

float rand(uint seed, float frameSeed) {
    return float(combineSeed(seed, frameSeed)) / 4294967296.0; // 2^32
}

*/

struct particle {
   vec2 position;
   vec2 velocity;
   float scale;
   float life;
   vec4 color;
};

struct ParticleSystemConfiguration {
   int particleCount;
   bool burstMode;
   float spawnRate; // particles per second
   float particleLifeSpan; // seconds
   float gravity;
   float startSize; 
   float endSize;
   vec4 startColor;
   vec4 endColor;
};

struct ParticleGroup_large{
   particle particles[MAX_PARTICLES_LARGE];
};

layout(std430, set = 0, binding = 0) buffer ObjectInstaceBuffer_config{
	ParticleSystemConfiguration configs[MAX_PARTICLE_SYSTEMS_LARGE];
};

layout(std430, set = 0, binding = 1) buffer ObjectInstaceBuffer_large{
	ParticleGroup_large particleGroups_large[MAX_PARTICLE_SYSTEMS_LARGE];
};

layout(push_constant) uniform constants{
   int systemIndex;
   float deltaTime;
   //float rndSeed;
};


float random (float seed) {
    return fract(sin(dot(vec2(seed, seed * 235.54323), vec2(12.9898,78.233)))* 43758.5453123);
}

#define ps particleGroups_large[systemIndex].particles

layout(set = 0, binding = 2) buffer AtomicCounterBuffer {
    uint activeCount;
} acBuffer;

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

void main() {
    uint id = gl_GlobalInvocationID.x;
   
   ParticleSystemConfiguration con = configs[systemIndex];

   // TODO: add reset operation to the push constant which sets life and scale of all particles to 0
   // mirror CPU simulation exactly
   
    // Reactivate dead particles if less than 5 have been reactivated this frame
    if (ps[id].life == 0) {
        uint count = atomicAdd(acBuffer.activeCount, 1);
        if (count < 5) {
            ps[id].life = 1.0;
            ps[id].position = vec2(0.0, 0.0);
            ps[id].velocity = vec2(random(id + 2.6543), random(id + 45.6245));
            ps[id].color = con.startColor;
            ps[id].scale = con.startSize;
        }
    } else {
      ps[id].velocity.y += con.gravity * deltaTime;
      ps[id].position += ps[id].velocity * deltaTime;
      ps[id].life -= deltaTime;
      if (ps[id].life <= 0.0) {
         ps[id].life = 0.0; 
      }
    }

}

   //  if (ps[id].life == 0) {
   //      uint count = atomicCounterIncrement(activeCount);
   //      if (count < 5) {
   //          ps[id].life = 1.0;
   //          ps[id].position = vec2(0.0, 0.0);
   //          ps[id].velocity = vec2(random(id), random(id + 45.6245));
   //          ps[id].color = con.startColor;
   //      }
   //  } else {