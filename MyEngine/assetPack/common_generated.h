// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_ASSETPACK_H_
#define FLATBUFFERS_GENERATED_COMMON_ASSETPACK_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace AssetPack {

struct vec2;

enum FilterMode : int32_t {
  FilterMode_Nearest = 0,
  FilterMode_Linear = 1,
  FilterMode_MIN = FilterMode_Nearest,
  FilterMode_MAX = FilterMode_Linear
};

inline const FilterMode (&EnumValuesFilterMode())[2] {
  static const FilterMode values[] = {
    FilterMode_Nearest,
    FilterMode_Linear
  };
  return values;
}

inline const char * const *EnumNamesFilterMode() {
  static const char * const names[3] = {
    "Nearest",
    "Linear",
    nullptr
  };
  return names;
}

inline const char *EnumNameFilterMode(FilterMode e) {
  if (::flatbuffers::IsOutRange(e, FilterMode_Nearest, FilterMode_Linear)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFilterMode()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  vec2()
      : x_(0),
        y_(0) {
  }
  vec2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(vec2, 8);

}  // namespace AssetPack

#endif  // FLATBUFFERS_GENERATED_COMMON_ASSETPACK_H_
