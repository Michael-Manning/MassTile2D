

- switch color and texture instancing piplines to fixed secondar command buffer. Use drawIndirect to update instance count with buffer. Profile first
(Could just use camera buffer since I'm already updating that every frame!)
Update: Since draw command is always last, could put everything in the secondary buffer, but then add the draw call to the end every frame

- convert worldToScreenPos & screenToWorldPos into simple matrix calculation? Profile first

- convert entity transform into component, store in contiguous memory, or use faster map. Then use compute shader to calculate
entity transform matrices for color/texture pipeline instead of per vertex calculation


- Inter-bahaviour entity accessor
- general behaviour scene access for camera and common data needs


- player buffer jump input

delete large chunk transfer buffer after world is loaded in. Create functions to repeate this process easily

could have some sort of optional set on an entity listing what components it's using to make it faster to delete them

reserve scene component maps with max count to prevenent rehashing which would break getComponent pointers. GPT told me this, is it even real?
- same with pipiline texture references which use raw pointers


integrate vk-bootstrap to simplify initializion
- move tilemap push constant to UBO (use new ubo uploader class)



- tool for managing texture bindings. Replace function in instanced pipline


- shader auto workflow with sprv reflect


things to abstract:

- buffer management (group allocation and buffer, see vkguide)

- group together descriptor layout, set, and write creation in a class

- default quad vertex management







---- features:

- texture animators

- partical system

- text

- more physics features. raycast, collision detection, layers, user entity variable in body