
Near roadmap:
- particle system serialization
- auto save prefabs to folder instead of openging save file dialog
- new behaviour system
- refactor prefab to contain scene data allowing entity hierarchies
- add prefab preview/edit utility to editor
- add deletion of components to editor
- flatten assets in editor view into one list with drop down sorting
- remove shared ptr use from: scene, Input manager, vulkan engine, asset manager, resource manager, componentAccessor
- finish scene desctructor
- update serialization to not use shared_ptr

---- Test:
- entity deleation
- nested prefab with all component types
- full serialization setup and publish build

Major optimization:
Sprites store their image file name, and texture IDs are hashed from the same filename. Could stop serializing the textureID
in the sprite (and remove the requirement they be consistent and persistent), then use texture IDs directly in the bindless
texture manager, removing one of the 3 layers of inderection required to link a sprite renderer to the actual GPU image

- editor issue with selectables when entities have the same name. Problem when instantiating prefabs with same name as existing entity

- component deletion from editor

- switch all deserialization functions to constructors for uniformity, simplicity, as well as slight performance boost as components could all
be emplaced into maps instead of constructed, coppied, and destructed;

- drag prefab to instantiate

- only enable used device features instead of enabling everything for the sake of bindless textures

- text render spaces don't work with kerning hash lookup

- support downscaled resolution (run full screen at lower resolution than monitor resolution)

- fix getkeyup

- allow mapped buffer creation with explicit flushing of memory ranges

- replace file path string concatenation all over engine with filesystem api (to elemenate having to check for trailing slahes on directory paths)

- Inter-bahaviour entity accessor

- general behaviour scene access for camera and common data needs

- player buffer jump input

delete large chunk transfer buffer after world is loaded in. Create functions to repeate this process easily

could have some sort of optional set on an entity listing what components it's using to make it faster to delete them

- replace upload text data function with zero copy method for uploading data

- sprv reflect

- create default font

- check if the the swapchain is out of date earlier in the engine loop so that we can potentially bail out of submitting work which will not
be displayed which should reduce latency

- create bulk generate texture function to avoid having to recreate staging buffers and synchronize the graphics queue for every single texture creation

- query maxComputeWorkGroupCount, maxComputeWorkGroupInvocations, and maxComputeWorkGroupSize to determine max work group size

- for mapped double buffers (instancing, lighting), populate data directly into void pointer instead constructing an array and calling memcpy

- could look into cachine pointers in components, such as caching the texture index binding directly to the sprite or sprite renderer to skip map lookups
on entities which are drawn for multiple frames(basically all of them)

- disallow rigidbodies on child entities

- change particle system rendere host allocation logic to delay actual creation of the particle buffer until/if the particle data is actually accessed.
There are instances such as with prefab loading that a particle system renderer allocates a large host buffer, but the data is never actually used
for anything, and the class is just used as a clone template


---- things to abstract:

- buffer management (group allocation and buffer, see vkguide)

- descriptor pool sizes


---- features:

- texture animator

- more physics features. raycast, collision detection, layers, user entity variable in body
