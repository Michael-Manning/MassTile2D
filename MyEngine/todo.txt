


Just added font asset. Continue adding scene support, then fully hook up text renderer and text pipline
- incorporate font baseline


- fix getkeyup




- convert entity transform into component, store in contiguous memory, or use faster map. Then use compute shader to calculate
entity transform matrices for color/texture pipeline instead of per vertex calculation - profile first


- Inter-bahaviour entity accessor

- general behaviour scene access for camera and common data needs

- player buffer jump input

delete large chunk transfer buffer after world is loaded in. Create functions to repeate this process easily

could have some sort of optional set on an entity listing what components it's using to make it faster to delete them

reserve scene component maps with max count to prevenent rehashing which would break getComponent pointers. GPT told me this, is it even real?
- same with pipiline texture references which use raw pointers


integrate vk-bootstrap to simplify initializion

- tool for managing texture bindings. Replace function in instanced pipline

- shader auto workflow with sprv reflect


things to abstract:

- buffer management (group allocation and buffer, see vkguide)


- query maxComputeWorkGroupCount, maxComputeWorkGroupInvocations, and maxComputeWorkGroupSize to determine max work group size

- for mapped double buffers (instancing, lighting), populate data directly into void pointer instead constructing an array and calling memcpy


---- features:

- texture animators

- partical system

- more physics features. raycast, collision detection, layers, user entity variable in body