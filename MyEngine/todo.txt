
 - screen space fonts
 - screen space textures (or all in one pipeline)

- fix getkeyup

- asset move/destroy/copy operators causing problems in asset loading if not preloading all assets when sprite/font destructor called

- load asset via sprite/font id set flawed as it has to load every asset meta just to check it's ID, then discards it if it's the wrong ID.
Could get around this by building some sort of lookup file which contains the IDs of all assets by filename or by creating a way of "peaking" IDs

- convert entity transform into component, store in contiguous memory, or use faster map. Then use compute shader to calculate
entity transform matrices for color/texture pipeline instead of per vertex calculation - profile first

- replace file path string concatenation with filesystem api (to elemenate having to check for trailing slahes on directory paths)

- Inter-bahaviour entity accessor

- general behaviour scene access for camera and common data needs

- player buffer jump input

delete large chunk transfer buffer after world is loaded in. Create functions to repeate this process easily

could have some sort of optional set on an entity listing what components it's using to make it faster to delete them

reserve scene component maps with max count to prevenent rehashing which would break getComponent pointers. GPT told me this, is it even real?
- same with pipiline texture references which use raw pointers

- replace upload text data function with zero copy method for uploading data

integrate vk-bootstrap to simplify initializion

- tool for managing texture bindings. Replace function in instanced pipline

- shader auto workflow with sprv reflect

- replace "spritesAdded" flag with something more descriptive. Doesn't work as well when a font sprite is added before the font metadata which actually signals
the font pipeline that a new ID binding should be created

- create default 

things to abstract:

- buffer management (group allocation and buffer, see vkguide)

- descriptor pool sizes

- query maxComputeWorkGroupCount, maxComputeWorkGroupInvocations, and maxComputeWorkGroupSize to determine max work group size

- for mapped double buffers (instancing, lighting), populate data directly into void pointer instead constructing an array and calling memcpy


---- features:

- texture animators

- partical system

- more physics features. raycast, collision detection, layers, user entity variable in body